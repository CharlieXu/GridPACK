! ------------- SUBROUTIEN ------------------

      SUBROUTINE MAKEYBUS
      
!     WRITTEN BY YOUSU CHEN, PNNL, 03/10/2007
!     LAST MODIFIED BY YOUSU CHEN, PNNL 04/10/2007
!     $ID: MAKEYBUS.F, V1.04 2007/04/10
!
!     REVISION LOG
!     2007/04/10
!     1: CHANGED LOCAL ARRAYS TO ALLOCATABLE ARRAYS
! --------------- DESCRIPTION ---------------
!
!     THIS PROGRAM BUILDS YBUS MATRIX, AND YF, YT MATRIX
!      
!-------------------------------------------------

      USE BUSMODULE, ONLY:NB,NS,BUS_I,GS,BS
      USE BRCHMODULE
      USE YBUSMODULE
      USE OTHERMODULE
      USE CONSTANTS
      USE INTRIFUNS
      USE FLAGS
      IMPLICIT NONE

!     LOCAL ARGUMENT DECLARATION
      INTEGER :: I, J, FLAG,COUNTCF,COUNTCT,COUNTYSH
      INTEGER, ALLOCATABLE,DIMENSION(:) :: ICOLCF,VALCF,ICOLCT,VALCT,
     &ICOLYFF,ICOLCFT,ICOLCTT,VALCFT,VALCTT,VALYFF,ICOLY1,ICOLY2,ICOLY3,
     &ICOLY4,IROWCF,IROWCT,IROWYFF,IROWY1,IROWY2,IROWY3,IROWY4,IROWCFT,
     &IROWCTT,IROWTEMP1,ICOLTEMP1,IROWTEMP2,ICOLTEMP2,IROWTEMP3,
     &ICOLTEMP3,IROWYSH,ICOLYSH
      REAL(KIND=DP),ALLOCATABLE, DIMENSION(:) :: THETA, BC
      COMPLEX(KIND=DP),ALLOCATABLE, DIMENSION(:) :: YS,YFF,YTT,YFT,YTF,
     &     VALCFF_CPLX,VALCFT_CPLX,VALCTF_CPLX,VALCTT_CPLX,VALY1,VALY2,
     &     VALY3,VALY4,VALTEMP1,VALTEMP2, VALTEMP3,YSH,VALYSH
      INTEGER :: NZY1,NZY2,NZY3,NZY4,NZ1,NZ2,NZ3
!      
!      --- END OF DECLARATION ---
!

!
!     ------- ALLOCATABLE ARRAYS --------
!
      IF (ALLOCATED(IROWCF)) DEALLOCATE(IROWCF)
      IF (ALLOCATED(ICOLCF)) DEALLOCATE(ICOLCF)
      IF (ALLOCATED(VALCF)) DEALLOCATE(VALCF)
      IF (ALLOCATED(IROWCT)) DEALLOCATE(IROWCT)
      IF (ALLOCATED(ICOLCT)) DEALLOCATE(ICOLCT)
      IF (ALLOCATED(VALCT)) DEALLOCATE(VALCT)
      IF (ALLOCATED(IROWCFT)) DEALLOCATE(IROWCFT)
      IF (ALLOCATED(ICOLCFT)) DEALLOCATE(ICOLCFT)
      IF (ALLOCATED(VALCFT)) DEALLOCATE(VALCFT)
      IF (ALLOCATED(IROWCTT)) DEALLOCATE(IROWCTT)
      IF (ALLOCATED(ICOLCTT)) DEALLOCATE(ICOLCTT)
      IF (ALLOCATED(VALCTT)) DEALLOCATE(VALCTT)
      IF (ALLOCATED(ICOLYFF)) DEALLOCATE(ICOLYFF)
      IF (ALLOCATED(IROWYFF)) DEALLOCATE(IROWYFF)
      IF (ALLOCATED(VALYFF)) DEALLOCATE(VALYFF)
      IF (ALLOCATED(IROWY1)) DEALLOCATE(IROWY1)
      IF (ALLOCATED(IROWY2)) DEALLOCATE(IROWY2)
      IF (ALLOCATED(IROWY3)) DEALLOCATE(IROWY3)
      IF (ALLOCATED(IROWY4)) DEALLOCATE(IROWY4)
      IF (ALLOCATED(ICOLY1)) DEALLOCATE(ICOLY1)
      IF (ALLOCATED(ICOLY2)) DEALLOCATE(ICOLY2)
      IF (ALLOCATED(ICOLY3)) DEALLOCATE(ICOLY3)
      IF (ALLOCATED(ICOLY4)) DEALLOCATE(ICOLY4)
      IF (ALLOCATED(VALY1)) DEALLOCATE(VALY1)
      IF (ALLOCATED(VALY2)) DEALLOCATE(VALY2)
      IF (ALLOCATED(VALY3)) DEALLOCATE(VALY3)
      IF (ALLOCATED(VALY4)) DEALLOCATE(VALY4)
      IF (ALLOCATED(IROWTEMP1)) DEALLOCATE(IROWTEMP1)
      IF (ALLOCATED(IROWTEMP2)) DEALLOCATE(IROWTEMP2)
      IF (ALLOCATED(IROWTEMP3)) DEALLOCATE(IROWTEMP3)
      IF (ALLOCATED(ICOLTEMP1)) DEALLOCATE(ICOLTEMP1)
      IF (ALLOCATED(ICOLTEMP2)) DEALLOCATE(ICOLTEMP2)
      IF (ALLOCATED(ICOLTEMP3)) DEALLOCATE(ICOLTEMP3)
      IF (ALLOCATED(VALTEMP1)) DEALLOCATE(VALTEMP1)
      IF (ALLOCATED(VALTEMP2)) DEALLOCATE(VALTEMP2)
      IF (ALLOCATED(VALTEMP3)) DEALLOCATE(VALTEMP3)
      IF (ALLOCATED(IROWYSH)) DEALLOCATE(IROWYSH)
      IF (ALLOCATED(ICOLYSH)) DEALLOCATE(ICOLYSH)
      IF (ALLOCATED(VALYSH)) DEALLOCATE(VALYSH)
      IF (ALLOCATED(YSH)) DEALLOCATE(YSH)
      IF (ALLOCATED(YS)) DEALLOCATE(YS)
      IF (ALLOCATED(THETA)) DEALLOCATE(THETA)
      IF (ALLOCATED(BC)) DEALLOCATE(BC)
      IF (ALLOCATED(YFF)) DEALLOCATE(YFF)
      IF (ALLOCATED(YTT)) DEALLOCATE(YTT)
      IF (ALLOCATED(YFT)) DEALLOCATE(YFT)
      IF (ALLOCATED(YTF)) DEALLOCATE(YTF)
      IF (ALLOCATED(VALCFF_CPLX)) DEALLOCATE(VALCFF_CPLX)
      IF (ALLOCATED(VALCFT_CPLX)) DEALLOCATE(VALCFT_CPLX)
      IF (ALLOCATED(VALCTF_CPLX)) DEALLOCATE(VALCTF_CPLX)
      IF (ALLOCATED(VALCTT_CPLX)) DEALLOCATE(VALCTT_CPLX)

      
      ALLOCATE(ICOLCF(NBRCH),VALCF(NBRCH),ICOLCT(NBRCH),VALCT(NBRCH),
     &ICOLYFF(NBRCH),ICOLCFT(NBRCH),ICOLCTT(NBRCH),VALCFT(NBRCH),
     &VALCTT(NBRCH),VALYFF(NBRCH),ICOLY1(NBRCH),ICOLY2(NBRCH),
     &ICOLY3(NBRCH),ICOLY4(NBRCH),IROWCF(NB+1),IROWCT(NB+1),
     &IROWYFF(NB+1),IROWY1(NB+1),IROWY2(NB+1),IROWY3(NB+1),IROWY4(NB+1),
     &IROWCFT(NBRCH+1),IROWCTT(NBRCH+1),IROWTEMP1(NB+1),
     &ICOLTEMP1(2*NBRCH),IROWTEMP2(NB+1),ICOLTEMP2(3*NBRCH),
     &IROWTEMP3(NB+1),ICOLTEMP3(4*NBRCH),IROWYSH(NB+1),ICOLYSH(NS),
     &THETA(NBRCH),BC(NBRCH),YS(NBRCH),YFF(NBRCH),YTT(NBRCH)
     &,YFT(NBRCH),YTF(NBRCH),VALCFF_CPLX(NBRCH),VALCFT_CPLX(NBRCH),
     &VALCTF_CPLX(NBRCH),VALCTT_CPLX(NBRCH),VALY1(NBRCH),VALY2(NBRCH),
     &VALY3(NBRCH),VALY4(NBRCH),VALTEMP1(2*NBRCH),VALTEMP2(3*NBRCH),
     &VALTEMP3(4*NBRCH),YSH(NB),VALYSH(NS),STAT=ERROR)
      IF (ERROR /=0) THEN
         PRINT *, " ------------------ ERROR ------------------------"
         PRINT *, " PROGRAM COULD NOT ALLOCATE SPACE FOR YBUS RELATED 
     &  ARRAYS"
         STOP
      END IF

!
!     --------  CHECK THE BUS NUMBERS ARE EQUAL TO INDICES TO BUS (ONE SET OF BUS NUMBERS)
!
      FLAG = 0
      DO I = 1,NB
         IF (BUS_I(I) .NE. I) FLAG = 1
      END DO
      IF (FLAG .EQ. 1) THEN
         WRITE(*,*) ' ERROR: BUSES MUST APPEAR IN ORDER BY BUS NUMBER'
         STOP
      END IF
!     --------- END OF CHECKING BUS NUMBER ---------------

!      PRINT *, ''
!      PRINT *, '   MAKING YBUS...   '
!      PRINT *, ''
			
      YS = BR_STATUS/DCMPLX(BR_R,BR_X)
      BC = BR_STATUS * BR_B
      WHERE (TAP .EQ. 0) TAP = 1.0  ! DEFAULT TAP RATIO = 1
      THETA = -PI*SHIFT/180.0
      TAP_CPLX =DCMPLX(TAP*COS(THETA), TAP*SIN(THETA))
      YTT = YS + DCMPLX(0,BC/2)        
      YFF = YTT / (TAP_CPLX * CONJG(TAP_CPLX))      
      YFT = - YS / CONJG(TAP_CPLX)
      YTF = - YS / TAP_CPLX
!      YTT = YS + DCMPLX(0,BC/2)        
!      YFF = YTT / (TAP * TAP)      
!      YFT = - YS / TAP
!      YTF = - YS / TAP
      YSH = DCMPLX(GS,BS)
      
      IROWYSH(1) = 1      
      COUNTYSH = 0
      DO I = 1, NB
         IF (YSH(I) .EQ. 0) IROWYSH(I+1) = IROWYSH(I)
         IF (YSH(I) .NE.0) THEN
            IROWYSH(I+1) = IROWYSH(I) + 1
            COUNTYSH = COUNTYSH + 1
            ICOLYSH(COUNTYSH) = I
            VALYSH(COUNTYSH) = YSH(I)
         END IF
      END DO
!
!     CONNECTION MATRIX FOR LINE & FROM/TO BUSES CF AND CT
!     SPARSE MATRIX FORM, COMPRESS ROW FORMAT

      IROWCF = 0
      IROWCT = 0
      IROWCF(1) = 1
      IROWCT(1) = 1
      DO I = 1,NB
            COUNTCF = 0
            COUNTCT = 0
            DO J = 1, NBRCH
                  IF (F_BUS(J) .EQ. I ) COUNTCF = COUNTCF + 1 
                  IF (T_BUS(J) .EQ. I ) COUNTCT = COUNTCT + 1
            END DO         
            IROWCF(I+1) = COUNTCF + IROWCF(I)
            IROWCT(I+1) = COUNTCT + IROWCT(I)
      END DO      
      CALL GETICOL (F_BUS,ICOLCF,NBRCH)
      CALL GETICOL (T_BUS,ICOLCT,NBRCH)
      VALCF = 1
      VALCT = 1
      VALCFT = 1
      VALCTT = 1

!     CF * SPDIAGS(YFF, 0, NL, NL) * CF'
!     CF * SPDIAGS(YFT, 0, NL, NL) * CT'
!     CT * SPDIAGS(YTF, 0, NL, NL) * CF'
!     CT * SPDIAGS(YTT, 0, NL, NL) * CT'

      CALL MATMULDIAG(IROWCF,ICOLCF,VALCF,YFF,VALCFF_CPLX)
      CALL MATMULDIAG(IROWCF,ICOLCF,VALCF,YFT,VALCFT_CPLX)
      CALL MATMULDIAG(IROWCT,ICOLCT,VALCT,YTF,VALCTF_CPLX)
      CALL MATMULDIAG(IROWCT,ICOLCT,VALCT,YTT,VALCTT_CPLX)
!
!     GET IROW, ICOL FOR CF' AND CT'. 
!
      DO I = 1, NBRCH
         IROWCFT(I) = I ! ONE ELEMENT PER ROW
         IROWCTT(I) = I
         ICOLCFT(I) = F_BUS(I)
         ICOLCTT(I) = T_BUS(I)
      END DO
      IROWCFT(NBRCH+1) = NBRCH + 1
      IROWCTT(NBRCH+1) = NBRCH + 1
      
      CALL CMATMULIMAT(IROWCF,ICOLCF,VALCFF_CPLX,IROWCFT,ICOLCFT,VALCFT,
     &  NB,NBRCH,NB,IROWY1,ICOLY1,VALY1,NZY1)      
      CALL CMATMULIMAT(IROWCF,ICOLCF,VALCFT_CPLX,IROWCTT,ICOLCTT,VALCTT,
     &  NB,NBRCH,NB,IROWY2,ICOLY2,VALY2,NZY2)
      CALL CMATMULIMAT(IROWCT,ICOLCT,VALCTF_CPLX,IROWCFT,ICOLCFT,VALCFT,
     &  NB,NBRCH,NB,IROWY3,ICOLY3,VALY3,NZY3)
      CALL CMATMULIMAT(IROWCT,ICOLCT,VALCTT_CPLX,IROWCTT,ICOLCTT,VALCTT,
     &  NB,NBRCH,NB,IROWY4,ICOLY4,VALY4,NZY4)

      CALL MATADDMAT (IROWY1,ICOLY1,VALY1,IROWY2,ICOLY2,VALY2,IROWTEMP1
     &              ,ICOLTEMP1,VALTEMP1,NB,NB,NBRCH,NBRCH,NZ1,1)      
      CALL MATADDMAT (IROWTEMP1,ICOLTEMP1,VALTEMP1,IROWY3,ICOLY3,VALY3,
     &         IROWTEMP2,ICOLTEMP2,VALTEMP2,NB,NB,NBRCH+NZ1,NBRCH,NZ2,1)
      CALL MATADDMAT (IROWTEMP2,ICOLTEMP2,VALTEMP2,IROWY4,ICOLY4,VALY4,
     &          IROWTEMP3,ICOLTEMP3,VALTEMP3,NB,NB,NZ2,NBRCH,NZ3,1)
      CALL MATADDMAT (IROWTEMP3,ICOLTEMP3,VALTEMP3,IROWYSH,ICOLYSH,    
     &       VALYSH,IROWYBUS,ICOLYBUS,VALYBUS,NB,NB,NZ3,NS,NZYBUS,1)

!
!     CREATE YF AND YT SUCH THAT YF * V IS THE VECTOR OF COMPLEX BRANCH CURRENTS
!     INJECTED AT EACH BRANCH'S "FROM" BUS, AND YT IS THE SAME FOR THE "TO" BUS.

!
!      --- IROW ---
!
      IROWYF(1) = 1
      IROWYT(1) = 1
      DO I = 2,NBRCH+1
         IROWYF(I) = IROWYF(I-1) + 2
         IROWYT(I) = IROWYT(I-1) + 2
      END DO
      
!     
!     --- ICOL & VAL ---
!     
      J = 0
      DO I = 1,NBRCH
         J = 2*I - 1
         IF (F_BUS(I) .LT. T_BUS(I) ) THEN
            ICOLYF(J) = F_BUS(I)            
              ICOLYT(J) = F_BUS(I)
            ICOLYF(J+1) = T_BUS(I)
            ICOLYT(J+1) = T_BUS(I)
              VALYF(J) = YFF(I)
              VALYF(J+1) = YFT(I)
              VALYT(J) = YTF(I)
              VALYT(J+1) = YTT(I)
         ELSE
              ICOLYF(J) = T_BUS(I)            
              ICOLYT(J) = T_BUS(I)
            ICOLYF(J+1) = F_BUS(I)
            ICOLYT(J+1) = F_BUS(I)
              VALYF(J) = YFT(I)
              VALYF(J+1) = YFF(I)
              VALYT(J) = YTT(I)
              VALYT(J+1) = YFT(I)
         END IF
      END DO

!
!     ------- DEALLOCATE ARRAYS --------
!
      IF (ALLOCATED(IROWCF)) DEALLOCATE(IROWCF)
      IF (ALLOCATED(ICOLCF)) DEALLOCATE(ICOLCF)
      IF (ALLOCATED(VALCF)) DEALLOCATE(VALCF)
      IF (ALLOCATED(IROWCT)) DEALLOCATE(IROWCT)
      IF (ALLOCATED(ICOLCT)) DEALLOCATE(ICOLCT)
      IF (ALLOCATED(VALCT)) DEALLOCATE(VALCT)
      IF (ALLOCATED(IROWCFT)) DEALLOCATE(IROWCFT)
      IF (ALLOCATED(ICOLCFT)) DEALLOCATE(ICOLCFT)
      IF (ALLOCATED(VALCFT)) DEALLOCATE(VALCFT)
      IF (ALLOCATED(IROWCTT)) DEALLOCATE(IROWCTT)
      IF (ALLOCATED(ICOLCTT)) DEALLOCATE(ICOLCTT)
      IF (ALLOCATED(VALCTT)) DEALLOCATE(VALCTT)
      IF (ALLOCATED(ICOLYFF)) DEALLOCATE(ICOLYFF)
      IF (ALLOCATED(IROWYFF)) DEALLOCATE(IROWYFF)
      IF (ALLOCATED(VALYFF)) DEALLOCATE(VALYFF)
      IF (ALLOCATED(IROWY1)) DEALLOCATE(IROWY1)
      IF (ALLOCATED(IROWY2)) DEALLOCATE(IROWY2)
      IF (ALLOCATED(IROWY3)) DEALLOCATE(IROWY3)
      IF (ALLOCATED(IROWY4)) DEALLOCATE(IROWY4)
      IF (ALLOCATED(ICOLY1)) DEALLOCATE(ICOLY1)
      IF (ALLOCATED(ICOLY2)) DEALLOCATE(ICOLY2)
      IF (ALLOCATED(ICOLY3)) DEALLOCATE(ICOLY3)
      IF (ALLOCATED(ICOLY4)) DEALLOCATE(ICOLY4)
      IF (ALLOCATED(VALY1)) DEALLOCATE(VALY1)
      IF (ALLOCATED(VALY2)) DEALLOCATE(VALY2)
      IF (ALLOCATED(VALY3)) DEALLOCATE(VALY3)
      IF (ALLOCATED(VALY4)) DEALLOCATE(VALY4)
      IF (ALLOCATED(IROWTEMP1)) DEALLOCATE(IROWTEMP1)
      IF (ALLOCATED(IROWTEMP2)) DEALLOCATE(IROWTEMP2)
      IF (ALLOCATED(IROWTEMP3)) DEALLOCATE(IROWTEMP3)
      IF (ALLOCATED(ICOLTEMP1)) DEALLOCATE(ICOLTEMP1)
      IF (ALLOCATED(ICOLTEMP2)) DEALLOCATE(ICOLTEMP2)
      IF (ALLOCATED(ICOLTEMP3)) DEALLOCATE(ICOLTEMP3)
      IF (ALLOCATED(VALTEMP1)) DEALLOCATE(VALTEMP1)
      IF (ALLOCATED(VALTEMP2)) DEALLOCATE(VALTEMP2)
      IF (ALLOCATED(VALTEMP3)) DEALLOCATE(VALTEMP3)
      IF (ALLOCATED(IROWYSH)) DEALLOCATE(IROWYSH)
      IF (ALLOCATED(ICOLYSH)) DEALLOCATE(ICOLYSH)
      IF (ALLOCATED(VALYSH)) DEALLOCATE(VALYSH)
      IF (ALLOCATED(YSH)) DEALLOCATE(YSH)
      IF (ALLOCATED(YS)) DEALLOCATE(YS)
      IF (ALLOCATED(THETA)) DEALLOCATE(THETA)
      IF (ALLOCATED(BC)) DEALLOCATE(BC)
      IF (ALLOCATED(YFF)) DEALLOCATE(YFF)
      IF (ALLOCATED(YTT)) DEALLOCATE(YTT)
      IF (ALLOCATED(YFT)) DEALLOCATE(YFT)
      IF (ALLOCATED(YTF)) DEALLOCATE(YTF)
      IF (ALLOCATED(VALCFF_CPLX)) DEALLOCATE(VALCFF_CPLX)
      IF (ALLOCATED(VALCFT_CPLX)) DEALLOCATE(VALCFT_CPLX)
      IF (ALLOCATED(VALCTF_CPLX)) DEALLOCATE(VALCTF_CPLX)
      IF (ALLOCATED(VALCTT_CPLX)) DEALLOCATE(VALCTT_CPLX)

      RETURN      
      END
!
!     --- END OF MAKEYBUS MAIN PROGRAM ---
!
!
!     -------------------- SUBROUTINES ----------------------------
!
!
!     --------- SUBROUTINE GETICOL -------------
!

      SUBROUTINE GETICOL (BUS1,ICOL,N)
!     GET ICOL BASED ON BUS. (SORT)
      
      IMPLICIT NONE

!     DUMMY ARGUMENT DECLARATION
      INTEGER,INTENT(IN)::  N
      INTEGER,INTENT(IN)::  BUS1(N)
      INTEGER,INTENT(OUT):: ICOL(N)

!     LOCAL ARGUMENT DECLARATION
      INTEGER  TEMPBUS,I,J,TEMPICOL,BUS(N)
!      
!      --- END OF DECLARATION ---
!
      BUS=BUS1
      DO I = 1,N
         ICOL(I) = I
      END DO
      DO I = N,2,-1
         IF (BUS(I) .LT. BUS(I-1) ) THEN
            TEMPBUS = BUS(I-1)
            BUS(I-1) = BUS(I)
            BUS(I) = TEMPBUS
            TEMPICOL = ICOL(I-1)
            ICOL(I-1) = ICOL(I)
            ICOL(I) = TEMPICOL
          END IF
      END DO
      
      DO I = 3, N
         J = I
         TEMPBUS = BUS(I)
         TEMPICOL = ICOL(I)
         DO WHILE (TEMPBUS .LT. BUS(J-1))
             BUS(J) = BUS(J-1)
               ICOL(J) = ICOL(J-1)
             J = J-1
         END DO 
         BUS(J) = TEMPBUS
         ICOL(J) = TEMPICOL
      END DO

      RETURN
      END SUBROUTINE GETICOL
!
!     --------- SUBROUTINE MATMULDIAG -------------
!

      SUBROUTINE  MATMULDIAG(IROW,ICOL,VAL,DIAG,VAL_CPLX)
!     PRODUCT OF VAL_CPLX = A*DIAG
!      A IS INTEGER MATRIX
!      DIAG AND VAL_CPLX ARE COMPLEX DIAGANOL MATRICES
      USE ALLMODULE
      IMPLICIT NONE

!     DUMMY ARGUMENTS 
      INTEGER, INTENT(IN)      :: VAL(NBRCH)
      INTEGER, INTENT(INOUT) :: IROW (NB+1),ICOL(NBRCH)
      COMPLEX(KIND=DP), INTENT(IN) :: DIAG(NBRCH)
      COMPLEX(KIND=DP), INTENT(OUT) :: VAL_CPLX(NBRCH)

!     LOCAL ARGUMENTS      
      INTEGER :: I,J,K,IAA,IAB,IBA,IBB,ICA,ICB,IP,JP,KP
      INTEGER, DIMENSION(:) :: IROWB(NBRCH+1),ICOLB(NBRCH)
      COMPLEX(KIND=DP), DIMENSION(NB) :: X(NBRCH+1)
      COMPLEX(KIND=DP) :: A

!      
!      --- END OF DECLARATION ---
!
      DO I = 1,NB
       IF (IROW(I+1)-1 .GE. IROW(I) ) THEN
            DO J = IROW(I),IROW(I+1)-1
                  VAL_CPLX(J) = VAL(J) * DIAG(ICOL(J)) 
            END DO
       END IF
      END DO
      
      RETURN
      END SUBROUTINE MATMULDIAG

!     -------- SUBROUTINE CMATMULIMAT ------------
      SUBROUTINE CMATMULIMAT(IROWA,ICOLA,VALA,IROWB,ICOLB,VALB,
     &   NP,NQ,NR,IROWC,ICOLC,VALC,NZ)
!     MULTIPLICATION OF TWO SPARSE MATRICES  C = A(NP*NQ) * B(NQ*NR)
!      A IS COMPLEX MATRIX, B IS INTEGER MATRIX
!     INPUT: IROWA,ICOLA,VALA,IROWB,ICOLB,VALB,NP,NQ,NR
!     OUTPUT: IROWC,ICOLC,VALC

      USE DEFDP 
      IMPLICIT NONE

!      DUMMY ARGUMENTS:
      INTEGER,INTENT(IN) :: NP,NQ,NR
      INTEGER,INTENT(IN) :: IROWA(NP+1),ICOLA(NQ),
     &                      IROWB(NQ+1),ICOLB(NQ),VALB(NQ)!ONE ELEMENT PER ROW
      COMPLEX(KIND=DP), INTENT(IN) :: VALA(NQ) !ONE ELEMENT PER COLUMN/ROW

      INTEGER, INTENT(OUT) :: IROWC(NP+1),ICOLC(NQ),NZ
      COMPLEX(KIND=DP), INTENT(OUT) :: VALC(NQ)

!     LOCAL ARGUMENTS:
      INTEGER :: I,J,K,IP,JP,KP,IAA,IAB,IBA,IBB,ICA,ICB,IAC
      INTEGER :: TMP,INDEX,FIRST,ERROR
      INTEGER, DIMENSION(:) :: IX(NR) 
!      INTEGER, ALLOCATABLE,DIMENSION(:) :: TEMP
      INTEGER, DIMENSION(:) :: TEMP(5000)
      COMPLEX(KIND=DP), DIMENSION(:) :: X(NR)
      COMPLEX(KIND=DP) :: A
!      
!      --- END OF DECLARATION ---
!

!
!      --- SYMBOLIC MULTIPLICATION ---
!
      IP = 1
      IX = 0
      DO I = 1, NP
         IROWC(I) = IP
         IAA = IROWA(I)
         IAB = IROWA(I+1) - 1
         IF (IAB .GE. IAA) THEN
              DO JP = IAA,IAB
               J = ICOLA(JP)
                   IBA = IROWB(J)
                   IBB = IROWB(J+1) - 1
               IF (IBB .GE. IBA) THEN
                    DO KP  = IBA,IBB
                     K = ICOLB(KP)
                     IF (K.LT.1) THEN
                          PRINT *, "K LESS THAN 1 !", K
                          PRINT *, "KP =", KP
                          PRINT *, "ICOLB=", ICOLB
                     ENDIF
                     IF (IX(K) .NE. I) THEN
                        ICOLC(IP) = K
                              IP = IP + 1
                              IX(K) = I
                     END IF
                  END DO
               END IF
              END DO
            END IF
      END DO
      IROWC(NP+1) = IP
      NZ = IP-1
!
!       SORT ICOLC EACH ROWC
!
      DO I = 1,NP
         IAA = IROWC(I)
         IAB = IROWC(I+1) 
         IAC = IAB - IAA
         IF (IAC .GT. 1) THEN
!            IF(ALLOCATED(TEMP)) DEALLOCATE(TEMP,STAT = ERROR)
!              IF(ERROR /=0) PRINT *, 'DYNAMIC ARRAY ERROR'
!            ALLOCATE(TEMP(IAC+1000),STAT=ERROR)
!            IF(ERROR /=0) PRINT *, 'DYNAMIC ARRAY ERROR'
              DO J = 1, IAC
               TEMP(J) = ICOLC(J+IAA - 1)
            END DO
            DO J = 1, IAC - 1
               FIRST = TEMP(J)
               INDEX = J
               DO K = J + 1, IAC
                  IF (TEMP(K) < FIRST) THEN 
                     FIRST = TEMP(K)
                     INDEX = K
                  END IF
               END DO
               IF (INDEX /= J ) THEN
                  TMP = TEMP(J)
                  TEMP(J) = TEMP (INDEX)
                  TEMP(INDEX) = TMP
               END IF
            END DO
              DO J = 1, IAC
               ICOLC(J+IAA - 1) = TEMP(J)
            END DO
         END IF
      END DO
!
!      --- NUMERICAL MULTIPLICATION ---
!
      DO I = 1, NP
         ICA = IROWC(I)
         ICB = IROWC(I+1) - 1
         IF (ICB .GE. ICA) THEN
            DO J = ICA, ICB
                 X(ICOLC(J)) = 0.0
            END DO
            IAA = IROWA(I)
            IAB = IROWA(I+1) - 1
            DO JP = IAA,IAB
               J = ICOLA(JP)
               A = VALA(JP)
               IBA = IROWB(J)
               IBB = IROWB(J+1)-1
               IF (IBB .GE. IBA) THEN
                  DO KP = IROWB(J),IROWB(J+1)-1
                     K = ICOLB(KP)
                          X(K) = X(K) + A*VALB(KP)
                  END DO
               END IF
            END DO
              DO J = IROWC(I),IROWC(I+1) -1
                VALC(J) = X(ICOLC(J))
              END DO
         END IF
      END DO
     
      RETURN
      END SUBROUTINE CMATMULIMAT
!
!     -------- SUBROUTINE PRINTSPARSE ------------           
!
      SUBROUTINE PRINTSPARSE(IROW,ICOL,VAL,N,NZ)
      ! DISPLAY SPARSE MATRIX
      USE DEFDP
      IMPLICIT NONE

      ! DUMMY ARGUMENTS
      INTEGER, INTENT(IN) :: N,NZ,IROW(N+1),ICOL(NZ)
      REAL (KIND=DP), INTENT(IN) :: VAL(NZ)
      
      ! LOCAL ARGUMENTS
      INTEGER :: I,J
!      
!      --- END OF DECLARATION ---
!      
      DO I = 1,N
       
          PRINT *, I, (VAL(J), J = IROW(I),IROW(I+1)-1),
     &       (ICOL(J), J = IROW(I),IROW(I+1)-1)
       
      END DO

      RETURN
      END SUBROUTINE PRINTSPARSE
   
!
!     -------- SUBROUTINE PRINTCSPARSE ------------           
!
      SUBROUTINE PRINTCSPARSE(IROW,ICOL,VAL,N,NZ)
      ! DISPLAY COMPLEX SPARSE MATRIX
      USE DEFDP
      IMPLICIT NONE

      ! DUMMY ARGUMENTS
      INTEGER, INTENT(IN) :: N,NZ,IROW(N+1),ICOL(NZ)
      COMPLEX (KIND=DP), INTENT(IN) :: VAL(NZ)
      
      ! LOCAL ARGUMENTS
      INTEGER :: I,J
!      
!      --- END OF DECLARATION ---
!     
      OPEN(11,FILE='NEWYBUS',STATUS='UNKNOWN')
      DO I = 1,N
       
          WRITE(11,*) I, (VAL(J), J = IROW(I),IROW(I+1)-1),
     &       (ICOL(J), J = IROW(I),IROW(I+1)-1)
       
      END DO
      CLOSE(11)

      RETURN
      END SUBROUTINE PRINTCSPARSE
!
!     -------- SUBROUTINE MATADDMAT ------------
!
      SUBROUTINE MATADDMAT (IROWA,ICOLA,VALA,IROWB,ICOLB,VALB,IROWC
     &              ,ICOLC,VALC,N,M,NZ1,NZ2,NZ3,OPT)
      ! ADDITION OF TWO SPARSE MATRICES      
      ! C = A + B  (DIMENSION (N*M))
      ! NZ1,NZ2,NZ3 IS THE NUMBER OF NONZERO ELEMENTS IN MATRIX A, B, C, RESPECTIVELY
      ! OPT = 0 : DO NOT DO SYMBOLIC ADDITION ( THE LOCATION OF NONZERO ELEMENT DOES NOT CHANGE)
      ! OPT = 1 : DO SYMBOLIC ADDITION

      USE DEFDP
      IMPLICIT NONE

      ! DUMMY ARGUMENTS
      INTEGER,INTENT(IN) :: N,M,NZ1,NZ2,OPT
      INTEGER,INTENT(IN),DIMENSION(N+1) :: IROWA,IROWB
      INTEGER,INTENT(IN),DIMENSION(NZ1+NZ2) :: ICOLA,ICOLB
      COMPLEX(KIND=DP),INTENT(IN),DIMENSION(NZ1+NZ2) :: VALA,VALB

      INTEGER,INTENT(OUT) :: IROWC(N+1),ICOLC(NZ1+NZ2),NZ3
      COMPLEX(KIND=DP),INTENT(OUT) :: VALC(NZ1+NZ2)

      ! LOCAL ARGUMENTS
      INTEGER :: I,J,K,IP,JP,IAA,IAB,IBA,IBB,ICA,ICB,IAC
      INTEGER,DIMENSION(:) :: IX(M)
      COMPLEX(KIND=DP),DIMENSION(:) :: X(M)
      INTEGER :: TMP,INDEX,FIRST,ERROR
      INTEGER,DIMENSION(:) :: TEMP(10000)

!      
!      --- END OF DECLARATION ---
!
!      IF (ME.EQ.0) PRINT *, 'MAT ADD START '

!      
!       --- SYMBOLIC ADDITION ---
!
      IF ( OPT .EQ. 1) THEN 
            IP = 1
            IX = 0
            DO I = 1,N
                  IROWC(I) = IP
                  IAA = IROWA(I)
                  IAB = IROWA(I+1) -1
                  IF (IAB .GE. IAA) THEN
                        DO JP = IAA,IAB
                               J = ICOLA(JP)
                              ICOLC(IP) = J
                              IP = IP + 1
                              IX(J) = I
                          END DO
                  END IF
                  IBA = IROWB(I)
                  IBB = IROWB(I+1) - 1
                  IF (IBB .GE. IBA) THEN
                        DO JP = IBA,IBB
                        J = ICOLB(JP)
                              IF (IX(J) .NE. I) THEN
                                    ICOLC(IP) = J      
                                    IP = IP + 1
                              END IF
                        END DO
                  END IF
            END DO
            IROWC(N+1) = IP
!
!       SORT ICOLC EACH ROWC
!
            DO I = 1,N
                IAA = IROWC(I)
                  IAB = IROWC(I+1) 
                  IAC = IAB - IAA
                  IF (IAC .GT. 1) THEN
!                        IF(ALLOCATED(TEMP)) DEALLOCATE(TEMP,STAT = ERROR)
!                        IF(ERROR /=0) PRINT *, 'DYNAMIC ARRAY ERROR'
!                        ALLOCATE(TEMP(IAC+100),STAT=ERROR)
!                        IF(ERROR /=0) PRINT *, 'DYNAMIC ARRAY ERROR'
                        DO J = 1, IAC
                              TEMP(J) = ICOLC(J+IAA - 1)
                        END DO
                        DO J = 1, IAC - 1
                              FIRST = TEMP(J)
                              INDEX = J
                              DO K = J + 1, IAC
                                    IF (TEMP(K) < FIRST) THEN 
                                          FIRST = TEMP(K)
                                          INDEX = K
                                    END IF
                              END DO
                              IF (INDEX /= J ) THEN
                                    TMP = TEMP(J)
                                    TEMP(J) = TEMP (INDEX)
                                    TEMP(INDEX) = TMP
                              END IF
                        END DO
                        DO J = 1, IAC
                        ICOLC(J+IAA - 1) = TEMP(J)
                        END DO
                  END IF
            END DO
      END IF

      IF ( OPT .EQ. 0) THEN
            IROWC = IROWA
            ICOLC = ICOLA
      END IF
!
!       --- NUMERICAL ADDITION ---
!
      DO I = 1,N
         ICA = IROWC(I)
         ICB = IROWC(I+1) -1
         IF (ICB .GE. ICA) THEN
            DO IP = ICA,ICB
               X(ICOLC(IP)) = 0.0
            END DO  
              IAA = IROWA(I)
              IAB = IROWA(I+1) -1
            IF (IAB .GE. IAA) THEN
               DO IP = IAA,IAB
                  X(ICOLA(IP)) = VALA(IP)
               END DO
             END IF
             IBA = IROWB(I)
             IBB = IROWB(I+1) - 1
               IF ( IBB .GE. IBA) THEN
                DO IP = IBA,IBB
                   J = ICOLB(IP)
                   X(J) = X(J) + VALB(IP)
                 END DO
             END IF
             DO IP = ICA,ICB
                VALC(IP) = X(ICOLC(IP))
             END DO
         END IF
      END DO
      NZ3 = IP-1      
         
      RETURN
      END SUBROUTINE MATADDMAT
