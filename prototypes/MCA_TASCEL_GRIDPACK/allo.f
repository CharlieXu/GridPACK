!
! --------  POWER FLOW SIMULATION MODULES -------- 
!
! ===================================================
!
!    WRITETEN BY YOUSU CHEN, PNNL, 28 MARCH 2007
!    LAST MODIFIED BY YOUSU CHEN, PNNL, 06 JUNE 2007
!    $ID: ALLO.F, V1.04 2007/6/06
!
!    REVISION LOG
!    2007/4/20
!    ADD JACOBI, SUPERLU, SUBS MODULES
!    2007/4/26
!    ADD MATMULDIAG SUBROUTINE
!    2007/06/06
!    (1) ADDED CAMODULE
!    (2) ADDED VALYBUSSAVE
!        ARRAYS FOR CONTINGENCY ANALYSIS
!    2007/06/14
!    (1) ADDED PFSAVE,QFSAVE,PTSAVE,QTSAVE ARRAYS 
!    (2) ADDED VMSAVE,VASAVE ARRAYS 
!     2007/06/15
!     (1) ADDED SBUSSAVE ARRAY FOR CONTINGENCY ANALYSIS
!     2007/06/18
!     (1) ADDED PVSAVE, PQSAVE ARRAY FOR CONTINGENCY ANALYSIS
!     (2) ADDED V0SAVE ARRAY FOR CONTINGENCY ANALYSIS
!     (3) ADDED GBUSSAVE ARRAY
!     (4) ADDED NPVSAVE, NPQSAVE
!     2007/08/23
!     (1) ADDED GEN_STATUS1,GEN_STATUS2 FOR N-2,N-3 CONTINGENCY ANALYSIS
!     2007/08/24
!     (1) ADDED G1,G2,G3 FOR N-2,N-3 CONTINGENCY ANALYSIS
!     2008/02/18
!     (1) ADDED GID,GIND FOR STORING THE INFORMATION FOR ON GENERATORS
!     2008/02/19
!     (1) ADDED GIDSAVE,GINDSAVE FOR STORING THE INFORMATION FOR ON GENERATORS
!     2008/05/06
!     (1) ADDED NCASE1,NCASE2 AS THE NUMBER OF CASES FOR N-1/N-2 CA, RESPECTIVELY.


      MODULE DEFDP

      
!-------- DESCRIPTIONS --------
!    
!	DEFINE DOUBLE PRECISION
!-------------------------------
      INTEGER, PARAMETER :: DP = SELECTED_REAL_KIND(14)
      INTEGER :: ME,NPROC,NVIO,NDIV,NOK,NTOTAL
      INTEGER :: POSITION
      INTEGER :: ICASE,ICOUNT,BIN
      INTEGER :: LENG
      INTEGER, ALLOCATABLE,DIMENSION(:) :: REQUEST
      CHARACTER, ALLOCATABLE,DIMENSION(:) :: CASE_BUFF
      CHARACTER, ALLOCATABLE,DIMENSION(:) :: BUFF_OUT
      CHARACTER, ALLOCATABLE,DIMENSION(:) :: BUFF_A
      CHARACTER*1 :: COMMA  ! COMMA
      CHARACTER*1 :: NULLCHAR  ! "\0"
      CHARACTER*1 :: CASEFLAG
      CHARACTER*100 :: INPUTFILE
      CHARACTER*100 :: ARG_DIR   
      CHARACTER*100 :: CALISTNAME
      CHARACTER*100 :: NAME
      CHARACTER*100 :: CAFILE
      TYPE :: SINGLE_BUFF
          INTEGER :: IFROM
          INTEGER :: ITO
          CHARACTER*2 :: IBRID
          REAL(KIND=DP):: IMVALIM 
          INTEGER :: IDIV
          REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: IVM
          REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: IVV
          REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: IPL
          REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: ILV
      END TYPE SINGLE_BUFF
!      REAL(KIND=DP), DIMENSION(62873) :: SINGLE_OUTPUT 
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: SINGLE_OUTPUT
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: NPROC_OUTPUT 
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: ALL_OUTPUT 
      REAL(KIND=DP) :: SUMALL, SUMCOMP, SUMIO,SUMCNT
      INTEGER :: ITER,CONVERGED,IFMT,SOLOPT,STARTOPT
      INTEGER, PARAMETER :: MAX_IT = 10, ! MAXIMUM ITERATION NUMBER
     &          ISOLATE = 0  ! IF THERE IS ISOLATE BUS, SET ISOLATE = 1      
      REAL(KIND=DP), PARAMETER :: TOL = 1.0E-8
      INTEGER :: NXFMR_ADJ,NDC,NAREA,NSHUNT
!      INTEGER :: MAX_IT 
!      INTEGER, PARAMETER :: ISOLATE = 0  ! IF THERE IS ISOLATE BUS, SET ISOLATE = 1      
!      REAL(KIND=DP) :: TOL 

      !SHUNT DATA
      INTEGER, ALLOCATABLE, DIMENSION(:) :: SHUNT_BUS,MODSW,SWREM
      REAL(KIND=DP),ALLOCATABLE,DIMENSION(:):: VSWHI,VSWLO,BINIT
      INTEGER, ALLOCATABLE, DIMENSION(:) :: N1,N2,N3,N4,N5,N6,N7,N8
      REAL(KIND=DP),ALLOCATABLE,DIMENSION(:):: B1,B2,B3,B4,B5,B6,B7,B8
 
           

      END MODULE

! --------------------------------------- !
      
      MODULE CONSTANTS
      
!-------- DESCRIPTIONS --------
!
!     UNIVERSAL CONSTANTS:
      
      USE DEFDP
      
      REAL(KIND=DP), PARAMETER :: PI = 3.1415926535897932384626
      REAL(KIND=DP), PARAMETER :: EPS = 2.22E-10

      END MODULE

! --------------------------------------- !
      
      MODULE INTRIFUNS
      
!-------- DESCRIPTIONS --------
!
!     INTRINSIC FUNCTIONS
      
      USE DEFDP
      REAL(KIND=DP), INTRINSIC :: MAX, SQRT

      END MODULE
      
! --------------------------------------- !
      
      MODULE FLAGS
      
!-------- DESCRIPTIONS --------
!
!     FLAGS
! --------------------------------------- !
    
      INTEGER:: ERROR

      END MODULE
      
! --------------------------------------- !

      MODULE BUSMODULE 
!
! ---  BUS RELATED VARIABLES  --- 
!
      USE DEFDP

      INTEGER :: NB,SLACK,NS,NPV,NPQ,NPVSAVE,NPQSAVE
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BUS_I
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BUS_I_SAVE
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BUS_AREA
      INTEGER, ALLOCATABLE,DIMENSION(:) :: ZONE
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BUS_TYPE
      REAL(KIND=DP) :: BASEMVA
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: PD
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: QD
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: GS
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: BS
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VM
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VMHIGH
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VMLOW
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VA
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VMSAVE
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VASAVE
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: BASE_KV
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VMAX
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VMIN
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: LAM_P
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: LAM_Q
      CHARACTER*10, ALLOCATABLE, DIMENSION(:) :: BUSNAME
     
      END MODULE 

! --------------------------------------- !


      MODULE GENMODULE
!
! --- GENERATOR RELATED VARIABLES ---
!
      
      USE DEFDP 

      INTEGER :: NG,NGON,REFGEN,NGONSAVE
      INTEGER, ALLOCATABLE, DIMENSION(:) :: GEN_BUS
      INTEGER, ALLOCATABLE, DIMENSION(:) :: GBUS
      INTEGER, ALLOCATABLE, DIMENSION(:) :: GBUSSAVE
      INTEGER, ALLOCATABLE, DIMENSION(:) :: GIND
      INTEGER, ALLOCATABLE, DIMENSION(:) :: GINDSAVE
      CHARACTER*2,ALLOCATABLE,DIMENSION(:) :: GID
      CHARACTER*2,ALLOCATABLE,DIMENSION(:) :: GIDSAVE
!      INTEGER, ALLOCATABLE, DIMENSION(:) :: REFGEN
      INTEGER, ALLOCATABLE, DIMENSION(:) :: GEN_STATUS
      INTEGER, ALLOCATABLE, DIMENSION(:) :: GEN_STATUS_SAVE
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: PG
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: QG
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: QMAX
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: QMIN
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: VG
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: MBASE
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: PMAX
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: PPMAX !(GEN(ON,PMAX))
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: PMIN
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: PGG !(GEN(ON,PG))
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: PGGSAVE !(GEN(ON,PG))
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: QGG !(GEN(ON,QG))
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: QGGSAVE !(GEN(ON,PG))
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: QQMAX !(GEN(ON,QMAX))
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: QQMIN !(GEN(ON,QMIN))
      REAL(KIND=DP)  :: PMAXSLACK !(GEN(SLACK,PMAX))
      CHARACTER*2, ALLOCATABLE, DIMENSION(:) :: G_ID
      CHARACTER*2, ALLOCATABLE, DIMENSION(:) :: GEN_ID
      CHARACTER*2, ALLOCATABLE, DIMENSION(:) :: GEN_ID2
C    & ,MU_PMAX,MU_PMIN,MU_QMAX,MU_QMIN (FOR FUTURE DEVELOPMENT)

      END MODULE 

! --------------------------------------- !

      MODULE BRCHMODULE
      
!
! --- BRANCH MODULES ---
!
      
      USE DEFDP
      
      INTEGER :: NBRCH
      INTEGER, ALLOCATABLE,DIMENSION(:) :: F_BUS
      INTEGER, ALLOCATABLE,DIMENSION(:) :: F_BUS_SAVE
      INTEGER, ALLOCATABLE,DIMENSION(:) :: T_BUS
      INTEGER, ALLOCATABLE,DIMENSION(:) :: T_BUS_SAVE
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BR_STATUS
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BR_STATUS_SAVE
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: BR_R
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: BR_X
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: BR_B
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: RATE_A
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: RATE_B
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: RATE_C
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: TAP
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: SHIFT
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: PF
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: QF
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: PT
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: QT
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: PFSAVE
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: QFSAVE
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: PTSAVE
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: QTSAVE
      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: MVAHIGH
      CHARACTER*2, ALLOCATABLE,DIMENSION(:) :: BR_ID
      CHARACTER*2, ALLOCATABLE,DIMENSION(:) :: BR_ID2
C    &         MU_SF,MU_ST  (FOR FUTURE DEVELOPMENT)

      END MODULE 

!      MODULE SHUNTMODULE

!      USE DEFDP

!      INTEGER, ALLOCATABLE, DIMENSION(:) :: SHUNT_BUS
!      INTEGER, ALLOCATABLE, DIMENSION(:) :: MODSW
!      INTEGER, ALLOCATABLE, DIMENSION(:) :: SWREM
!      INTEGER, ALLOCATABLE, DIMENSION(:) :: N1
!      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VSWHI
!      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VSWLO
!      REAL(KIND=DP), ALLOCATABLE,DIMENSION(:) :: BINIT 

! --------------------------------------- !

!      END MODULE

      MODULE YBUSMODULE
      
!	
! -- YBUS RELATED VARIABLES ---
!
     
      USE DEFDP

      INTEGER :: NZYBUS, NZG,NZYF,NZYT
      INTEGER, ALLOCATABLE,DIMENSION(:) :: IROWYBUS
      INTEGER, ALLOCATABLE,DIMENSION(:) :: ICOLYBUS
      INTEGER, ALLOCATABLE,DIMENSION(:) :: IROWYF
      INTEGER, ALLOCATABLE,DIMENSION(:) :: IROWYT
      INTEGER, ALLOCATABLE,DIMENSION(:) :: ICOLYF
      INTEGER, ALLOCATABLE,DIMENSION(:) :: ICOLYT
      INTEGER, ALLOCATABLE,DIMENSION(:) :: IROWG
      INTEGER, ALLOCATABLE,DIMENSION(:) :: ICOLG
      COMPLEX(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VALYBUS
      COMPLEX(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VALYBUSSAVE
      COMPLEX(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VALYF
      COMPLEX(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VALYT
      COMPLEX(KIND=DP), ALLOCATABLE,DIMENSION(:) :: VALG

      END MODULE 
      
! --------------------------------------- !

      MODULE OTHERMODULE

!
! ---  OTHER VARIABLES ---
!

      USE DEFDP


      INTEGER, ALLOCATABLE, DIMENSION(:) :: PV
      INTEGER, ALLOCATABLE, DIMENSION(:) :: PVSAVE
      INTEGER, ALLOCATABLE, DIMENSION(:) :: PQ
      INTEGER, ALLOCATABLE, DIMENSION(:) :: PQSAVE
      INTEGER, ALLOCATABLE, DIMENSION(:) :: I2E
      INTEGER, ALLOCATABLE, DIMENSION(:) :: E2I
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: PGP
      REAL(KIND=DP), ALLOCATABLE, DIMENSION(:) :: QGP
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: V0
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: V0SAVE
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: V
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: SG
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: SF
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: ST
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: R
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: R1
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: R2
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: TAP_CPLX
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: LOSS
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: SBUS
      COMPLEX(KIND=DP), ALLOCATABLE, DIMENSION(:) :: SBUSSAVE

      END MODULE 


!
!      MODULE GENCOSTMODULE
!
! --- GENCOST RELATED VARIABLES (FOR FUTURE DEVELOPMENT) ---
!

!      CHARACTER,ALLOCATABLE,DIMENSION(:) :: MODEL
!      INTEGER, ALLOCATABLE,DIMENSION(:) :: STARTUP
!      INTEGER, ALLOCATABLE,DIMENSION(:) :: SHUTDOWN
!      INTEGER, ALLOCATABLE,DIMENSION(:) :: N
!      REAL (KIND=DP),ALLOCATABLE, DIMENSION(:) :: COST
!      REAL (KIND=DP),ALLOCATABLE, DIMENSION(:) :: COST1
!      REAL (KIND=DP),ALLOCATABLE, DIMENSION(:) :: COST2

!      END GENCOSTMODULE      
        
      MODULE JACOBI
      
      USE DEFDP

      INTEGER,ALLOCATABLE,DIMENSION(:) :: IROW12
      INTEGER,ALLOCATABLE,DIMENSION(:) :: ICOL12
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IROW34
      INTEGER,ALLOCATABLE,DIMENSION(:) :: ICOL34
      INTEGER,ALLOCATABLE,DIMENSION(:) :: IROWJ
      INTEGER,ALLOCATABLE,DIMENSION(:) :: ICOLJ
      REAL(KIND=DP),ALLOCATABLE,DIMENSION(:)::VAL12
      REAL(KIND=DP),ALLOCATABLE,DIMENSION(:)::VAL34
!     REAL(KIND=DP),ALLOCATABLE,DIMENSION(:)::VALJ

      END MODULE

      MODULE SUPERLU

      USE DEFDP

      INTEGER,ALLOCATABLE,DIMENSION(:) :: ROWIND
      INTEGER,ALLOCATABLE,DIMENSION(:) :: COLPTR
      REAL(KIND=DP),ALLOCATABLE,DIMENSION(:) :: VALUES

      END MODULE
      
      MODULE CAMODULE
      
      USE DEFDP
     
      INTEGER :: NCA
      INTEGER :: NCA0
      INTEGER :: NCAN
      INTEGER :: NGG
      INTEGER :: GENOPT
      INTEGER :: CA_F
      INTEGER :: CA_T
      INTEGER :: CA_IND
      INTEGER :: CAFLAG
      INTEGER :: CAOPT
      INTEGER :: OUTFLAG
      INTEGER :: M  !N-M CASE
      INTEGER :: NC ! # OF COUNTERS
      INTEGER :: NCASE
      INTEGER :: G1
      INTEGER :: G2
      INTEGER :: G3
      INTEGER :: IERR
      INTEGER :: NLINES
      CHARACTER*100 :: FN
      CHARACTER*100 :: FNTIME
      INTEGER, ALLOCATABLE,DIMENSION(:) :: IROWCA
      INTEGER, ALLOCATABLE,DIMENSION(:) :: N_OF_CA
      INTEGER, ALLOCATABLE,DIMENSION(:) :: CA_INDEX
      INTEGER, ALLOCATABLE,DIMENSION(:) :: CA_FROM
      INTEGER, ALLOCATABLE,DIMENSION(:) :: CA_TO
      INTEGER, ALLOCATABLE,DIMENSION(:) :: SEL_BRID 
      INTEGER, ALLOCATABLE,DIMENSION(:) :: CA_BRID 
      INTEGER, ALLOCATABLE,DIMENSION(:) :: CA_IROW
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BB
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BG
      INTEGER, ALLOCATABLE,DIMENSION(:) :: GG
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BBB
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BBG
      INTEGER, ALLOCATABLE,DIMENSION(:) :: BGG
      INTEGER, ALLOCATABLE,DIMENSION(:) :: GGG
      INTEGER, ALLOCATABLE,DIMENSION(:) :: N2_IDX1
      INTEGER, ALLOCATABLE,DIMENSION(:) :: N2_IDX2

      CHARACTER*5,ALLOCATABLE,DIMENSION(:) :: CA_NAME
      INTEGER ::ICOLCA(4)
      REAL(KIND=DP) :: MVALIM,MVALIMSAVE
      COMPLEX(KIND=DP) :: VALCA(4)
      COMPLEX(KIND=DP) :: YII
      COMPLEX(KIND=DP) :: YIJ
      COMPLEX(KIND=DP) :: YJI
      COMPLEX(KIND=DP) :: YJJ

      

      END MODULE
       
! --------------------------------------- !


      MODULE ALLMODULE

      USE CONSTANTS
      USE INTRIFUNS
      USE BUSMODULE
      USE GENMODULE
      USE BRCHMODULE
      USE YBUSMODULE
      USE CAMODULE
      USE OTHERMODULE
      USE FLAGS
!      USE SHUNTMODULE
      
      
      END MODULE

      MODULE CLOCK
      USE DEFDP

!      VARIABLES FOR SUBROUTINE SYSTEM_CLOCK
      INTEGER :: COUNT_0, COUNT_1, COUNT_RATE, COUNT_MAX      
      REAL(KIND=DP) :: T0,T1,ET,T_INI
      REAL(KIND=DP) :: T_CAL0,T_CAL1,T_VIO0,T_VIO1
      REAL(KIND=DP) :: T_CNT0,T_CNT1,T_OTH0,T_OTH1
      REAL(KIND=DP) :: T_ALL0,T_ALL1
      REAL(KIND=DP) :: TALL,TCOMP,TCNT
      REAL(KIND=DP) :: TVIO0,TVIO1,TVIO
      REAL(KIND=DP) :: TSOL1,TSOL0,TSOL
      REAL(KIND=DP) :: T_WR1,T_WR0,TWR

      END MODULE

      MODULE SUBS

      USE DEFDP

      CONTAINS

!
!      --- SUBROUTINE MATMULVEC ---
!
      SUBROUTINE MATMULVEC(IROW,ICOL,A,X,R,N,M,NZ)
!      
!      R = A * X
!      IROW, ICOL,A : INPUT MATRIX A
!      X :  VECTOR
!      R : RESULT MATRIX
!      N : THE NUMBER OF ROWS
!      M : THE NUMBER OF COLUMNS
!      NZ: THE NUMBER OF NON-ZERO ELEMENTS

      USE DEFDP      
      IMPLICIT NONE
      
      ! DUMMY ARGUMENTS
      INTEGER, INTENT(IN) :: N,M,NZ
      INTEGER, INTENT(IN), DIMENSION(:) :: IROW(N+1),ICOL(NZ)
      COMPLEX(KIND=DP), INTENT(IN), DIMENSION(:) :: A(NZ),X(M)
      COMPLEX(KIND=DP), INTENT(OUT), DIMENSION(:) :: R(N)

      ! LOCAL ARGUMENTS
      INTEGER :: I, J
      COMPLEX(KIND=DP) :: TEMP
!      
!      --- END OF DECLARATION ---
!
      DO I = 1, N
         TEMP = 0.0
         DO J = IROW(I), IROW(I + 1) - 1
            TEMP = TEMP + A(J) * X(ICOL(J))
         END DO
         R(I) = TEMP
      END DO
      
      RETURN
      END SUBROUTINE MATMULVEC

!
!      --- SUBROUTINE DSBUS_DV ---
      SUBROUTINE DSBUS_DV(IROWYBUS,ICOLYBUS,VALYBUS,V,IBUS,VALDVM,
     &      VALDVA,NB,NZ,ISOLATE)
      
      ! COMPUTES PARTIAL DERIVATIVES OF POWER INJECTION W.R.T. VOLTAGE.
      !   S = DIAG(V) * CONJ(IBUS) = DIAG(CONJ(IBUS)) * V
      !
      !   PARTIALS OF V & IBUS W.R.T. VOLTAGE VMNITUDES
      !       DV/DVM = DIAG(V./ABS(V))
      !       DI/DVM = YBUS * DV/DVM = YBUS * DIAG(V./ABS(V))
      !
      !   PARTIALS OF V & IBUS W.R.T. VOLTAGE VAS
      !       DV/DVA = J * DIAG(V)
      !       DI/DVA = YBUS * DV/DVA = YBUS * J * DIAG(V)
      !
      !   PARTIALS OF S W.R.T. VOLTAGE VMNITUDES
      !       DS/DVM = DIAG(V) * CONJ(DI/DVM) + DIAG(CONJ(IBUS)) * DV/DVM
      !              = DIAG(V) * CONJ(YBUS * DIAG(V./ABS(V)))
      !                                       + CONJ(DIAG(IBUS)) * DIAG(V./ABS(V))
      !
      !   PARTIALS OF S W.R.T. VOLTAGE VAS
      !       DS/DVA = DIAG(V) * CONJ(DI/DVA) + DIAG(CONJ(IBUS)) * DV/DVA      
      !              = DIAG(V) * CONJ(YBUS * J * DIAG(V))
      !                                       + CONJ(DIAG(IBUS)) * J * DIAG(V)
      !              = -J * DIAG(V) * CONJ(YBUS * DIAG(V))
      !                                       + CONJ(DIAG(IBUS)) * J * DIAG(V)
      !              = J * DIAG(V) * CONJ(DIAG(IBUS) - YBUS * DIAG(V))
      USE DEFDP
      USE CLOCK
      IMPLICIT NONE

      ! DUMMY ARGUMENTS
      INTEGER, INTENT(IN) :: NB,NZ,ISOLATE
      INTEGER, INTENT(IN), DIMENSION(:) :: IROWYBUS(NB+1),ICOLYBUS(NZ)
      COMPLEX(KIND=DP), INTENT(IN), DIMENSION(:) :: VALYBUS(NZ)
      COMPLEX(KIND=DP), INTENT(IN), DIMENSION(:) :: V(NB),IBUS(NB)
      COMPLEX(KIND=DP), INTENT(OUT),DIMENSION(:) :: VALDVM(NZ)
      COMPLEX(KIND=DP), INTENT(OUT),DIMENSION(:) :: VALDVA(NZ)
      
      ! LOCAL ARGUMENTS
      INTEGER :: I,J,NVM,NVA
      INTEGER, DIMENSION(:) :: ICOL(NB),IROW(NB+1),IROWDVM(NB+1),
     &            ICOLDVM(NZ),IROWDVA(NB+1),ICOLDVA(NZ)
      COMPLEX(KIND=DP), DIMENSION(:) :: DIAGV(NB),DIAGIBUS(NB)
      COMPLEX(KIND=DP), DIMENSION(:) :: DIAGVNORM(NB)
      COMPLEX(KIND=DP), DIMENSION(:) :: VAL1(NZ),VAL2(NB)
      COMPLEX(KIND=DP), PARAMETER    :: MINUS_ONE = -1.0
      COMPLEX(KIND=DP)               :: Z
!      
!      --- END OF DECLARATION ---
!
      Z = SQRT(MINUS_ONE)

      DO I = 1,NB
          IROW(I) = I
          ICOL(I) = I
          DIAGV(I) = V(I)
          DIAGIBUS(I) = IBUS(I)
          DIAGVNORM(I) = V(I)/ABS(V(I))
      END DO
      
      IROW(NB+1) = NB+1
!      
!      CALCULATE VAL1 = YBUS * DIAGVNORM
!
      VAL1 = VALYBUS
      CALL SYSTEM_CLOCK(COUNT_1, COUNT_RATE, COUNT_MAX)

!      DO I = 1,NZ
!            DO J = 1, NB
!                  IF (ICOLYBUS(I) .EQ. J) THEN
!                        VAL1(I) = VALYBUS(I) * DIAGVNORM(J)
!                  END IF
!            END DO
!      END DO

      CALL MATMULDIAG (IROWYBUS,ICOLYBUS,VALYBUS,DIAGVNORM,VAL1,NB,NZ)
      
      VAL1 = CONJG(VAL1)
!
!      VAL1 = DIAGV * CONJ(YBUS * DIAGVNORM)
!      
      
      CALL DIAGMULMAT (VAL1,DIAGV,NB,NZ)
!
!      VAL2 = CONJ(DIAGIBUS) * DIAVNORM;      
!
      DO I = 1, NB
            VAL2(I) = CONJG(DIAGIBUS(I)) * DIAGVNORM(I)
      END DO
!
!      VAL1+ VAL2
!      
!      IF (ME.EQ.0) PRINT *, '  4 - 1   '
      CALL MATADDMAT (IROWYBUS,ICOLYBUS,VAL1,IROW,ICOL,VAL2,IROWDVM
     &              ,ICOLDVM,VALDVM,NB,NB,NZ,NB,NVM,ISOLATE)
!      IF (ME.EQ.0) PRINT *, '  4   '

!       J * DIAGV * CONJ(DIAGIBUS - YBUS * DIAGV)
      
      VAL1 = 0.0      
      CALL MATMULDIAG (IROWYBUS,ICOLYBUS,VALYBUS,DIAGV,VAL1,NB,NZ)
!      
!      VAL1 = CONJG(DIAGIBUS-VAL1)
!
      CALL MATADDMAT (IROWYBUS,ICOLYBUS,-VAL1,IROW,ICOL,DIAGIBUS,IROWDVA
     &              ,ICOLDVA,VALDVA,NB,NB,NZ,NB,NVA,ISOLATE)

      VALDVA = CONJG(VALDVA)
      DIAGV = V
!
!      DIAGV * VALDVA
!
      CALL DIAGMULMAT ( VALDVA,DIAGV,NB,NZ)
!
!      VALDVA = J *VALDVA
!
      VALDVA = Z * VALDVA
      
      RETURN
      END SUBROUTINE DSBUS_DV

!
!      --- SUBROUTINE MATMULDIAG ---
!      
      SUBROUTINE DIAGMULMAT ( VAL,DIAG,N,NZ)
      !
      ! B = DA (D IS FULL DIAGONAL OF THE GIVEN DIAGONAL MATRIX)
      ! N IS THE NUMBER OF ROWS
      ! NZ IS THE NUMBER OF NONZERO NUMBER OF A
      USE DEFDP
      USE YBUSMODULE, ONLY:IROWYBUS
      IMPLICIT NONE

      ! DUMMY ARGUMENTS
      INTEGER, INTENT(IN) :: N,NZ      
      COMPLEX(KIND=DP), INTENT(IN),DIMENSION(:) :: DIAG(N)      
      COMPLEX(KIND=DP), INTENT(INOUT),DIMENSION(:) :: VAL(NZ)      
      
      ! LOCAL ARGUMENTS
      INTEGER :: I,J
      COMPLEX(KIND=DP) :: DD
      
      
      DO I = 1,N
         IF (IROWYBUS(I+1)-1 .GE. IROWYBUS(I)) THEN
            DD = DIAG(I)
            DO J = IROWYBUS(I), IROWYBUS(I+1)-1
               VAL(J) = VAL(J) * DD
              END DO
         END IF
      END DO

      RETURN      
      END SUBROUTINE DIAGMULMAT               

!
!      --- SUBROUTINE JSUBSET ---
!
      SUBROUTINE JSUBSET(IROW,ICOL,VAL,ROW,COL,N,NZ,NR,NC,
     &      IROWN,ICOLN,VALN,NZN)

      ! CREATES J11,J12,J21,J22 OF J MATRIX
      ! N: THE NUMBER OF ROWS
      ! NZ: THE NUMBER OF NONZERO ELEMENTS
      ! NR: THE LENGTH OF ROW
      ! NC: THE LENGTH OF COL      
      ! IROW,ICOL,VAL : ORIGINAL SPARSE MATRIX 
      ! ROW: REORDER ROW ARRAY ( E.G. [PV;PQ] FOR J11
      ! COL: REORDER COLUMN ARRAY (E.G. PQ FOR J22 )      
      ! IROWN,ICOLN,VALN : NEW SPARSE MATRIX
      ! NZN : THE NUMBER OF NONZERO ELEMENTS OF NEW MATRIX

      USE DEFDP
      IMPLICIT NONE
      !
      ! DUMMY ARGUMENTS
      INTEGER,INTENT(IN) :: N,NZ,NR,NC
      INTEGER,INTENT(IN),DIMENSION(:):: IROW(N+1),ICOL(NZ),ROW(NR)
     &       ,COL(NC)
      REAL(KIND=DP),INTENT(IN),DIMENSION(:):: VAL(NZ)
      
      INTEGER,INTENT(OUT) :: NZN
      INTEGER,INTENT(OUT),DIMENSION(:):: IROWN(N+1),ICOLN(NZ)
      REAL(KIND=DP),INTENT(OUT),DIMENSION(:):: VALN(NZ)
      ! LOCAL ARGUMENTS
      !INTEGER :: I,J,K,NR,NC,IAA,IAB,TMPI1,TMPI2,COUNT
      INTEGER :: NZR
      INTEGER, DIMENSION(:):: IROWR(N+1),ICOLR(NZ),IROWT(N+1),ICOLT(NZ)
      INTEGER, DIMENSION(:):: IROWR2(N+1),ICOLR2(NZ)
      REAL(KIND=DP), DIMENSION(:):: VALR(NZ),VALT(NZ),VALR2(NZ)
!      
!      --- END OF DECLARATION ---
!
      
      ! SELECT THE ROWS WHOES INDEXES ARE IN ARRAY "ROW", WRITE INTO
      ! NEW MATRIX, KEEPING COLUMN SAME
      ! (THE ROWS WHOES INDEXES ARE NOT IN ARRAY "ROW" WERE REMOVED)
      
      CALL SELECTROW(IROW,ICOL,VAL,ROW,IROWR,ICOLR,VALR,N,NZ,NR,NZR)

      !
      ! GET TRANSPORSE OF IROWT, THEN CONSIDER COLUMN EXCHANGE/REMOVE 
      ! AS ROW EXCHANGE FOR A TRANSPORT MATRIX
      !

      CALL GETTRANSPOSE (IROWR,ICOLR,VALR,NR,N,NZR,IROWT,ICOLT,VALT)

      CALL SELECTROW(IROWT,ICOLT,VALT,COL,IROWR2,ICOLR2,VALR2,N,NZR,
     &      NC,NZN)

      CALL GETTRANSPOSE (IROWR2,ICOLR2,VALR2,NC,NR,NZN,IROWN,ICOLN,VALN)
      
      RETURN
      END SUBROUTINE JSUBSET

!
!      SUBROUTINE SELECTROW
!
      SUBROUTINE SELECTROW(IROW,ICOL,VAL,ROW,IROWR,ICOLR,VALR,N,NZ,NR
     &      ,COUNT)
      ! BUILD A NEW MATRIX FROM AN ARRAY WHICH CONTAINS THE ROW INDEXES 
      ! OF ORIGINAL MATRIX.
      ! (THE ROWS WHOES INDICES ARE NOT IN ARRAY "ROW" WERE REMOVED)

      ! IROW,ICOL,VAL :ORIGINAL MATRIX
      ! ROW : ARRAY WHICH CONTAINS THE ROW INDEXES OF ORIGINAL MATRIX
      ! IROWR, ICOLR,VALR : THE NEW MATRIX AFTER ROW PERMUATION AND REMOVEMNENT
      ! N : THE NUMBER OF ROWS OF ORIGINAL MATRIX
      ! NZ : THE NUMBER OF NONZERO ELEMENTS OF ORIGINAL MATRIX
      ! NR : THE NUMBER OF ELEMENTS IN ROW ARRAY (AND IN THE NEW MATRIX)
      ! COUNT : THE NUMBER OF NONZERO ELEMENTS OF NEW MATRIX
      USE DEFDP
      IMPLICIT NONE

      ! DUMMY ARGUMENTS
      INTEGER,INTENT(IN) :: N,NZ,NR
      INTEGER,INTENT(IN),DIMENSION(:):: IROW(N+1),ICOL(NZ),ROW(N)
      REAL(KIND=DP),INTENT(IN),DIMENSION(:):: VAL(NZ)
      
      INTEGER,INTENT(OUT) :: COUNT ! THE NUMBER OF NONZERO ELEMENT IN NEW MATRIX
      INTEGER,INTENT(OUT),DIMENSION(:):: IROWR(N+1),ICOLR(NZ)
      REAL(KIND=DP),INTENT(OUT),DIMENSION(:):: VALR(NZ)

      ! LOCAL ARGUMENTS
      INTEGER :: I,J,IAA,IAB,TMPI1,TMPI2
!      
!      --- END OF DECLARATION ---
!

      IROWR(1) = 1
      COUNT = 1

      DO I = 1,NR
            IAA = IROW(ROW(I))
            IAB = IROW(ROW(I)+1)
            TMPI1 = IAB - IAA   ! THE NUMBER OF NONZERO ELEMENTS
                                                                ! IN ROW ROW(I)
            IROWR(I+1) = IROWR(I) + TMPI1 ! NEW IROW
            
            DO J = COUNT, COUNT+TMPI1-1                  
                  TMPI2 = IROW(ROW(I))            
                  ICOLR(J) = ICOL(TMPI2+J-COUNT) ! NEW ICOL
                  VALR(J) = VAL(TMPI2+J-COUNT)   ! NEW VAL
            END DO
            COUNT = COUNT + TMPI1    ! COUNT = THE NUMBER OF NONZERO IN NEW MATRIX
      END DO
      COUNT = COUNT -1

      RETURN
      END SUBROUTINE SELECTROW


!
!     -------- SUBROUTINE GETTRANSPOSE ------------
!

      SUBROUTINE GETTRANSPOSE (IROW,ICOL,VAL,N,M,NZ,IROWT,ICOLT,VALT)
!     GET TRANSPORSE OF A MATRIX
!--------------------------------------------
!      IROW,ICOL,VAL : ORIGINAL MATRIX
!      N : THE NUMBER OF ROWS
!      M : THE NUMBER OF COLUMNS
!      NZ : THE NUMBER OF NONZERO ELEMENTS
!      IROWT,ICOLT,VALT : TRANSPORSE MATRIX
      USE DEFDP
      IMPLICIT NONE
!     DUMMY ARGUMENTS
      INTEGER, INTENT(IN)      :: N,M,NZ
      INTEGER, INTENT(IN),DIMENSION(:) :: IROW(N+1),ICOL(NZ)
      REAL(KIND=DP), INTENT(IN),DIMENSION(:) :: VAL(NZ)
      INTEGER, INTENT(OUT),DIMENSION(:) :: IROWT(M+1),ICOLT(NZ)
      REAL(KIND=DP), INTENT(OUT),DIMENSION(:) :: VALT(NZ)

!      LOCAL ARGUMENTS      
      INTEGER :: I,J,K,JP,IAA,IAB
!      
!      --- END OF DECLARATION ---
!
      IROWT=0
      IROWT(1) = 1
      IROWT(2) = 1
      
      DO I = 1, IROW(N + 1) - 1
            J = ICOL(I) + 2
            IF ( J .LE. M + 1) IROWT(J) = IROWT(J) + 1
      END DO

      DO I = 3, M + 1
            IROWT(I) = IROWT(I) + IROWT(I-1)
      END DO

      DO I = 1,N
            IAA = IROW(I)
            IAB = IROW(I+1) - 1
            IF (IAB .GE. IAA) THEN 
                  DO JP = IAA, IAB
                        J = ICOL(JP) + 1
                        K = IROWT(J)
                        ICOLT(K) = I
                        VALT(K) = VAL(JP)
                           IROWT(J) = K + 1
                  END DO
            END IF         
      END DO
      
      RETURN
      END SUBROUTINE GETTRANSPOSE

!
!     -------- SUBROUTINE SIDECATENATE ------------
!
      SUBROUTINE SIDECATENATE(IROWA,ICOLA,VALA,IROWB,ICOLB,VALB,IROWAB,
     &      ICOLAB,VALAB,N,M,NZA,NZB)
      !  CATENATE MATRIX A AND MATRIX B TO MATRIX AB = [A B]            
      !  IROWA, ICOLA, VALA : MATRIX A
      !  IROWB, ICOLB, VALB : MATRIX B
      !  IROWAB, ICOLAB, VALAB : MATRIX AB
      !  N : THE NUMBER OF ROWS FOR MATRIX A/B (SAME)
      !  M : THE NUMBER OF COLUMNS FOR MATRIX A
      !  NZA,NZB : THE NUMBER OF NONZEROS ELEMENTS FOR MATRIX A AND MATRIX B
      USE DEFDP
      IMPLICIT NONE
      
      ! DUMMY ARGUMENTS
      INTEGER, INTENT(IN) :: N, M, NZA, NZB
      INTEGER, INTENT(IN), DIMENSION(:) :: IROWA(N+1),IROWB(N+1),
     &      ICOLA(NZA),ICOLB(NZB)
      REAL(KIND=DP), INTENT(IN), DIMENSION(:) :: VALA(NZA),VALB(NZB)
       
      INTEGER, INTENT(OUT), DIMENSION(:) :: IROWAB(N+1),ICOLAB(NZA+NZB)
      REAL(KIND=DP), INTENT(OUT), DIMENSION(:) :: VALAB(NZA+NZB)
      
      ! LOCAL ARGUMENTS
      INTEGER :: I,J,K,IAB
      INTEGER, DIMENSION(:) :: ICOLB2(NZB)
!      
!      --- END OF DECLARATION ---
!
      
      IROWAB(1) = 1
      DO I = 2, N+1
            IROWAB(I) = IROWAB(I-1) + (IROWA(I) - IROWA(I-1)) 
     &                        + (IROWB(I) - IROWB(I-1))
      END DO
      
      ICOLB2 = ICOLB + M
      IAB = 1
      DO I = 1,N
            DO J = IROWA(I), IROWA(I+1)-1
                  ICOLAB(IAB) = ICOLA(J)
                  VALAB(IAB) = VALA(J)
                  IAB = IAB + 1
            END DO
            DO K = IROWB(I), IROWB(I+1)-1
                  ICOLAB(IAB) = ICOLB2(K)
                  VALAB(IAB) = VALB(K)
                  IAB = IAB + 1
            END DO
      END DO                  

      RETURN
      END SUBROUTINE SIDECATENATE
                   
!
!     -------- SUBROUTINE UPDOWNCATENATE ------------
!
      SUBROUTINE UPDOWNCATENATE(IROWA,ICOLA,VALA,IROWB,ICOLB,VALB,IROWAB
     &      ,ICOLAB,VALAB,NA,NB,M,NZA,NZB)
           !  CATENATE MATRIX A AND MATRIX B TO MATRIX AB = [A
      !                                                                          B]            
      !  IROWA, ICOLA, VALA : MATRIX A
      !  IROWB, ICOLB, VALB : MATRIX B
      !  IROWAB, ICOLAB, VALAB : MATRIX AB
      !  NA, NB : THE NUMBER OF ROWS FOR MATRIX A AND MATRIX B
      !  M : THE NUMBER OF ROWS FOR MATRIX A/B (SAME)
      !  NZA,NZB : THE NUMBER OF NONZEROS ELEMENTS FOR MATRIX A AND MATRIX B
      USE DEFDP
      IMPLICIT NONE
      
      ! DUMMY ARGUMENTS
      INTEGER, INTENT(IN) :: NA, NB, M, NZA, NZB
      INTEGER, INTENT(IN), DIMENSION(:) :: IROWA(NA+1),IROWB(NB+1),
     &      ICOLA(NZA),ICOLB(NZB)
      REAL(KIND=DP), INTENT(IN), DIMENSION(:) :: VALA(NZA),VALB(NZB)
       
      INTEGER, INTENT(OUT), DIMENSION(:) :: IROWAB(NA+NB+1),
     & ICOLAB(NZA+NZB)     
      REAL(KIND=DP), INTENT(OUT), DIMENSION(:) :: VALAB(NZA+NZB)
      
      ! LOCAL ARGUMENTS
      INTEGER :: I,IAB, IROWB2(NB+1)
!      
!      --- END OF DECLARATION ---
!

      DO I = 1, NZA            
            ICOLAB(I) = ICOLA(I)
            VALAB(I) = VALA(I)
      END DO

      DO I = 1, NZB            
            ICOLAB(NZA+I) = ICOLB(I)
            VALAB(NZA+I) = VALB(I)            
      END DO
      
      DO I = 1, NA+1
            IROWAB(I) = IROWA(I)            
      END DO
      
      ! ADD (NZA - 1) TO WHOLE IROWB ARRAY, SO THAT THE FIRST ELEMENT IN IROWB IS NZA, INSTEAD OF 1. 
      IROWB2= IROWB + (NZA - 1)
      
      DO I = 1, NB
            IROWAB(NA+1+I) = IROWB2(I+1)+1
      END DO

      RETURN
      END SUBROUTINE UPDOWNCATENATE

!      SUBROUTINE MATMULDIAG (IROWA,ICOLA,VALA,DIAG,IROWB,ICOLB,VALB,N)
      SUBROUTINE MATMULDIAG (IROWA,ICOLA,VALA,DIAG,VALB,N,NZ)
      !
      ! B = AD (D IS FULL DIAGONAL OF THE GIVEN DIAGONAL MATRIX)
      ! N IS THE NUMBER OF ROWS
      ! NZ IS THE NUMBER OF NON-ZERO ELEMENTS IN A MATRIX
      ! THE IROW, ICOL ARRAY OF B MATRIX ARE SAME AS A MATRIX
      USE DEFDP
!      USE YBUSMODULE, ONLY:IROWYBUS
      IMPLICIT NONE

      ! DUMMY ARGUMENTS
      INTEGER, INTENT(IN) :: N,NZ
      COMPLEX(KIND=DP), INTENT(IN),DIMENSION(:) :: DIAG(N)      
      COMPLEX(KIND=DP), INTENT(IN),DIMENSION(:) :: VALA(NZ)      
      INTEGER, INTENT(IN),DIMENSION(:) :: IROWA(N+1)      
      INTEGER, INTENT(IN),DIMENSION(:) :: ICOLA(NZ)      
      COMPLEX(KIND=DP), INTENT(INOUT),DIMENSION(:) :: VALB(NZ)      
      
      ! LOCAL ARGUMENTS
      INTEGER :: I,J
      
      DO I = 1, N
         DO J = IROWA(I), IROWA(I+1) - 1
	      VALB(J) = VALA(J) * DIAG(ICOLA(J))
	 END DO
      END DO
      
!      DO I = 1, N 
!         IROWB(I) = IROWA(I)
!      END DO

!      DO J = IROWA(1), IROWA(N+1) - 1
!         ICOLB(J) = ICOLA(J)
!      END DO
      END SUBROUTINE MATMULDIAG

      SUBROUTINE REDUCE(IN_STR,OUT_STR)

       USE DEFDP
      IMPLICIT NONE

      ! DUMMY ARGUMENTS
      CHARACTER(*),INTENT(IN) ::IN_STR
      CHARACTER(LEN(IN_STR)),INTENT(OUT) ::OUT_STR
      CHARACTER :: C(LEN(IN_STR))
!      INTEGER :: DEST, SOURCE, BLANKS
      LOGICAL :: FLAG(LEN(IN_STR))

      C = TRANSFER(IN_STR,C)
      FLAG = C .EQ. '"' 
      FLAG(1:) = .NOT. (FLAG(:LEN(IN_STR)-1) .AND. FLAG(1:))
!      C(:COUNT(FLAG)) = PACK(C,FLAG)
!      C(COUNT(FLAG)+1:) = ' '
      OUT_STR=TRANSFER(PACK(C,FLAG),OUT_STR)

      END SUBROUTINE REDUCE

      END
